---
title: 十大排序算法总结（附Python代码）
author: Mingxian Yang
date: 2023-08-19 18:10:00 +0800
description: 随着众多成功的节奏游戏上市, 节奏游戏已成为游戏开发中的一大热门领域. 雷亚公司的Deemo以及Cytus和Cytus2在国内音游占有绝对优势, 还有在全球市场上占有绝对份额的老牌音游OSU!. 音乐游戏中大量的节拍需要大量的人力和时间成本，那么为什么不用代码分析节奏然后自动生成呢？Audiosurf的的创造者Dylan Fitterer开创了使用代码生成音游谱面的先河，并且取得了不错的成果。节拍映射成为了音乐游戏发展的一个重要方向。
categories: [Python,算法]
tags: [算法]
render_with_liquid: true
math: true
---



## 算法概述

### 算法分类
十种常见排序算法可以分为两大类： 
- 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 $O(nlogn)$，因此也称为非线性时间比较类排序。 
- 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 

![算法分类](/assets/imgs/2021/001.png)

### 算法复杂度
![算法复杂度](/assets/imgs/2021/002.png)

### 相关概念
- 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
- 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
- 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
- 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 

## 冒泡排序（Bubble Sort）
冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 

### 算法描述
- 比较相邻元素。如果第一个比第二个大，就交换它们两个；
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素会是最大的数；
- 针对所有元素重复以上的步骤，除了最后一个；
- 重复步骤1~3，直到排序完成。
- 
### 动画演示
![Bubble Sort](/assets/imgs/2021/003.gif)

### 代码实现
```python
def bubble_sort(nums):
    while 1:
        state = 0  # 假设本次循环没有改变
        for i in range(len(nums) - 1):
            if nums[i] > nums[i + 1]:
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
                state = 1  # 有数值交换，那么状态值置1
        if not state:  # 如果没有数值交换，那么就跳出
            break
```

## 选择排序（Selection Sort）
选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 

### 算法描述
n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：
- 初始状态：无序区为R[1..n]，有序区为空；
- 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
- n-1趟结束，数组有序化了。

### 动画演示
![Selection Sort](/assets/imgs/2021/004.gif)

### 代码实现

```python
def select_sort(nums):
    res = []
    while len(nums):
        min = [0, nums[0]]
        for i in range(len(nums)):
            if min[1] > nums[i]:
                min = [i, nums[i]]
        del nums[min[0]]  # 找到剩余部分的最小值，并且从原数组中删除
        res.append(min[1])  # 在新数组中添加
    return res
```