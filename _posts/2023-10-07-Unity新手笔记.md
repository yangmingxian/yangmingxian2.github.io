---
title: Unity新手笔记
author: Mingxian Yang
date: 2023-10-07 12:10:00 +0800
description: 有时候开发会遇到很多小小不言的问题，这些问题可能非常简单，但是我还是希望能记录下来。成长不就是聚沙成塔的过程吗。
categories: [Unity,游戏设计]
tags: [Unity]
render_with_liquid: false
---



### C#

1. 结构体(struct)和类(class)的混淆
   ~~~C#
   //定义了结构体
    public struct StatusInfo
    {
        public int stack;
        ... ...
    }

    //定义使用了结构体作为value的字典
    public Dictionary<Status, StatusInfo> statusDict = new();

    //这里的操作是会报错的：struct是mutable的
    if (statusDict.ContainsKey(statusDamage.status))
    {
        statusDict[index].stack+=1;
    }

   ~~~
    当StatusInfo定义为Class时，则不会出现错误，那么错误原因是什么也就在于Struct和Class的区别上了。  
    struct属于值类型，继承自System.ValueType(隐式继承自System.Objec)，存储于内存栈中，结构体使用后会自动释放内存，相对于class来的引用类型来说，要想改变struct里面元素的值，只能是new一个新的struct。在用习惯了引用类型那样的容器之后，确实容易忽略这一点。

    在给字典的结构体值赋值时，实际上是对字典中存储的副本进行操作。由于结构体是值类型，对副本的修改不会影响字典中原始的结构体实例。

    而类是引用类型，字典存储的是引用，而不是对象的副本。因此，对字典中类的实例进行操作时，实际上是对原始对象进行操作，而不是副本。

    因此，当你尝试修改字典中存储的结构体值时，编译器会报错，结构体是不可变（immutable）的。如果你想在字典中存储可变的状态信息，可以考虑使用类而不是结构体


    ---

    在C#中，结构体（struct）和类（class）是两种表示数据和行为的类型。它们有以下区别：

   - 语义差异：结构体是值类型（value type），而类是引用类型（reference type）。这意味着当结构体赋值给另一个变量或传递给方法时，会复制整个结构体的值；而类则是通过引用传递，多个变量可以引用同一个对象。

    - 内存分配：结构体通常分配在栈上，而类通常分配在托管堆（managed heap）上。由于栈上的内存分配和释放比堆上的操作更快，结构体适用于较小的数据类型，对于临时性的数据存储很有用。

   - 默认构造函数：在类中，如果没有显式定义构造函数，编译器会提供一个默认的无参构造函数。而在结构体中，如果没有显式定义构造函数，那么会有一个默认的无参构造函数，但是结构体也可以定义自己的构造函数。

   - 继承：类支持继承，可以派生出其他类，形成类的层次结构。而结构体不能继承其他结构体或类，它们只能实现接口。

   - 可空性：结构体可以通过在其定义中使用 ? 来使其可空，即可为null。而类默认是可为null的，除非显式使用 notnull 或 nonnull 进行标记。

   - 性能方面的考虑：由于结构体是值类型，它们的拷贝操作可能会导致性能开销。如果结构体较大，频繁进行复制操作可能会影响性能。在这种情况下，使用类可能更加合适。

    总的来说，当你需要处理较小的不可变数据时，或者需要高性能的堆栈分配时，可以考虑使用结构体。而对于需要引用语义、继承、动态分配和更复杂行为的情况，类是更常见和适合的选择。需要根据具体的场景和需求来选择结构体或类，以获得最佳的性能和设计
    
2. List的末尾元素 list[^-1]

    在C#中，list[^-1] 是一种从列表（List）的末尾开始索引的新语法。这种语法是C# 8.0引入的一项特性，称为“范围索引”（range indexing）。

    通过使用 [^-1]，可以方便地访问列表中的最后一个元素。它等效于使用索引 list[list.Count - 1] 来获取列表的最后一个元素。

    以下是一个示例，展示了如何使用 [^-1] 来获取列表的最后一个元素：
    ~~~C#
        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };
        int lastNumber = numbers[^-1];
        Console.WriteLine(lastNumber);  // 输出: 5
    ~~~  

    范围索引还支持其他语法，例如使用 [^2] 来获取倒数第二个元素，或使用 [^3..^1] 来获取倒数第三个到倒数第一个元素的范围。

    需要注意的是，范围索引仅适用于支持索引操作的类型，如数组和实现了索引器的集合类型（如 List<T>）。如果尝试在不支持索引操作的类型上使用范围索引，将导致编译错误。

### **Ref**   
http://www.gamelook.com.cn/2016/10/268460



 [**作者博客：YMX's Site**](http://yangmingxian.com/)  
 [**作者B站视频：CyberStreamer**](https://space.bilibili.com/22212765)




